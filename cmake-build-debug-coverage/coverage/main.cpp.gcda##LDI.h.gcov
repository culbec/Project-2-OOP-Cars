        -:    0:Source:/home/culbec/OOP/Project-2-OOP-Cars/Headers/LDI.h
        -:    0:Graph:/home/culbec/OOP/Project-2-OOP-Cars/cmake-build-debug-coverage/CMakeFiles/Project_2_OOP_Cars.dir/main.cpp.gcno
        -:    0:Data:/home/culbec/OOP/Project-2-OOP-Cars/cmake-build-debug-coverage/CMakeFiles/Project_2_OOP_Cars.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    1:#pragma once
        -:    2:
        -:    3:#include "IteratorLDI.h"
        -:    4:#include <string>
        -:    5:
        -:    6:using std::string;
        -:    7:
        -:    8:template<typename TElem>
        -:    9:class IteratorLDI;
        -:   10:
        -:   11:// LDI - clasa parametrizata
        -:   12:
        -:   13:template<typename TElem>
        -:   14:class Node {
        -:   15:private:
        -:   16:    // referinta catre precedentul & urmatorul nod
        -:   17:    Node<TElem> *prev;
        -:   18:    Node<TElem> *next;
        -:   19:    // informatia importanta
        -:   20:    TElem data;
        -:   21:public:
        -:   22:    /*
        -:   23:     * Node constructor
        -:   24:     * @pre: true
        -:   25:     * @post: se creeaza un nod
        -:   26:     */
        -:   27:    Node(TElem data, Node *prev, Node *next) : data{data}, prev{prev}, next{next} {}
        -:   28:
        -:   29:    // getters & setters
        -:   30:    TElem getData() const { return this->data; }
        -:   31:
        -:   32:    void setData(const TElem &elem) { this->data = elem; }
        -:   33:
        -:   34:    Node *getPrev() const { return this->prev; }
        -:   35:
        -:   36:    void setPrev(Node *prevS) {
        -:   37:        this->prev = prevS;
        -:   38:    }
        -:   39:
function _ZNK4NodeI3CarE7getNextEv called 0 returned 0% blocks executed 0%
    #####:   40:    Node<TElem> *getNext() const { return this->next; }
    %%%%%:   40-block  0
        -:   41:
        -:   42:    void setNext(Node *nextS) {
        -:   43:        this->next = nextS;
        -:   44:    }
        -:   45:};
        -:   46:
        -:   47:template<typename TElem>
        -:   48:class LDI {
        -:   49:    friend class IteratorLDI<TElem>;
        -:   50:
        -:   51:private:
        -:   52:    // clasa pentru nod -> elementul central din lista inlantuita
        -:   53:
        -:   54:    // interfata contine o referinta catre primul nod
        -:   55:    Node<TElem> *prim;
        -:   56:    // interfata contine o referinta catre ultimul nod
        -:   57:    Node<TElem> *ultim;
        -:   58:
        -:   59:    // si dimensiunea sa
        -:   60:    unsigned int sizeLDI;
        -:   61:
        -:   62:public:
        -:   63:    // constructor
        -:   64:    LDI<TElem>() : prim{nullptr}, ultim{nullptr}, sizeLDI{0} {}
        -:   65:
        -:   66:    // constructor de copiere
        -:   67:    LDI<TElem>(const LDI<TElem> &other) : prim{nullptr}, ultim{nullptr}, sizeLDI{0} {
        -:   68:        Node<TElem> *refOther = other.prim; // parcurgem lista pentru a adauga noile elemente
        -:   69:
        -:   70:        while (refOther != nullptr) {
        -:   71:            this->add(refOther->getData());
        -:   72:
        -:   73:            refOther = refOther->getNext();
        -:   74:        }
        -:   75:    }
        -:   76:
        -:   77:    // constructor de copiere (assignment)
        -:   78:    LDI<TElem> &operator=(const LDI<TElem> &other) {
        -:   79:        if (this == &other) // s-a facut L = L
        -:   80:            return *this;
        -:   81:
        -:   82:        // distrugem instanta curenta
        -:   83:        this->deleteNodes(this->prim);
        -:   84:        this->prim = nullptr;
        -:   85:        this->ultim = nullptr;
        -:   86:
        -:   87:        Node<TElem> *refOther = other.prim; // parcurgem lista pentru a adauga noile elemente
        -:   88:
        -:   89:        while (refOther != nullptr) {
        -:   90:            this->add(refOther->getData()); // adaugam elementul
        -:   91:
        -:   92:            refOther = refOther->getNext(); // iteram in continuare
        -:   93:        }
        -:   94:        this->sizeLDI = other.sizeLDI; // actualizam lungimea
        -:   95:
        -:   96:        return *this; // returnam lista
        -:   97:    }
        -:   98:
        -:   99:    // move constructor - fura datele de la other si il marcheaza pentru distrugere
        -:  100:    LDI<TElem>(LDI<TElem> &&other) noexcept: prim{other.prim}, ultim{other.ultim}, sizeLDI{other.sizeLDI} {
        -:  101:        // dealocam datele de la sursa de unde am mutat informatiile
        -:  102:        other.prim = nullptr;
        -:  103:        other.ultim = nullptr;
        -:  104:        other.sizeLDI = 0;
        -:  105:    }
        -:  106:
        -:  107:    // move constructor (assignment) - distruge instanta curenta, fura datele de la other si il marcheaza
        -:  108:    //                                 pentru distrugere
        -:  109:    LDI<TElem> &operator=(LDI<TElem> &&other) noexcept {
        -:  110:        if (this == &other) // s-a facut L = L
        -:  111:            return *this;
        -:  112:
        -:  113:        // stergem instanta curenta
        -:  114:        this->deleteNodes(this->prim);
        -:  115:
        -:  116:        // 'furam' datele
        -:  117:        this->prim = other.prim;
        -:  118:        this->ultim = other.ultim;
        -:  119:        this->sizeLDI = other.sizeLDI;
        -:  120:
        -:  121:        // il pregatim pe other pentru distrugere
        -:  122:        other.prim = nullptr;
        -:  123:        other.ultim = nullptr;
        -:  124:        other.sizeLDI = 0;
        -:  125:
        -:  126:        return *this;
        -:  127:    }
        -:  128:
        -:  129:    /**
        -:  130:     * @brief push_back pentru LDI
        -:  131:     * @pre true
        -:  132:     * @post se adauga elementul in lista inlantuita
        -:  133:     */
        -:  134:
        -:  135:    void push_back(const TElem &elem) {
        -:  136:        // instantiem un nod nou
        -:  137:        auto *nod = new Node<TElem>(elem, nullptr, nullptr);
        -:  138:
        -:  139:        // lista este goala
        -:  140:        if (this->prim == nullptr) {
        -:  141:            this->prim = nod;
        -:  142:            this->ultim = nod;
        -:  143:        }
        -:  144:            // lista nu este goala
        -:  145:        else {
        -:  146:            nod->setPrev(this->ultim);
        -:  147:            this->ultim->setNext(nod);
        -:  148:            this->ultim = nod;
        -:  149:        }
        -:  150:        // incrementam dimensiunea
        -:  151:        this->sizeLDI++;
        -:  152:    }
        -:  153:
        -:  154:    void add(const TElem &elem) {
        -:  155:        this->push_back(elem);
        -:  156:    }
        -:  157:
        -:  158:    // functie ce returneaza dimensiunea listei
        -:  159:    unsigned int size() const { return this->sizeLDI; }
        -:  160:
        -:  161:    // functie pentru verificarea listei vide
        -:  162:    bool empty() const { return this->sizeLDI == 0; }
        -:  163:
        -:  164:    /**
        -:  165:     * @brief Functia 'at' -> returneaza un element de pe o anumita pozitie
        -:  166:     * @param poz Pozitia elementului care va fi sters
        -:  167:     * @pre: poz -> pozitie valida din lista inlantuita
        -:  168:     * @post: elementul de pe pozitia poz sau
        -:  169:     */
        -:  170:    TElem at(unsigned int poz) const {
        -:  171:        // pastram o referinta catre primul element
        -:  172:        auto *ref = this->prim;
        -:  173:
        -:  174:        // iteram pana cand gasim elementul
        -:  175:        for (unsigned int i = 0; i < poz; i++)
        -:  176:            ref = ref->getNext();
        -:  177:
        -:  178:        // returnam elementul
        -:  179:        return ref->getData();
        -:  180:    }
        -:  181:
        -:  182:    TElem get(unsigned int poz) const {
        -:  183:        auto *ref = this->prim;
        -:  184:
        -:  185:        for (unsigned int i = 0; i < poz; i++)
        -:  186:            ref = ref->getNext();
        -:  187:
        -:  188:        return ref->getData();
        -:  189:    }
        -:  190:
        -:  191:    /**
        -:  192:     * @brief Functia 'erase' -> sterge un element de pe o anumita pozitie
        -:  193:     * @pre refElem -> referinta catre elementul de sters
        -:  194:     * @post elementul se va sterge din lista
        -:  195:     */
        -:  196:
        -:  197:    void erase(Node<TElem> *refElem) {
        -:  198:        if (this->sizeLDI == 1) {
        -:  199:            delete refElem;
        -:  200:            this->prim = nullptr;
        -:  201:            this->ultim = nullptr;
        -:  202:            this->sizeLDI--;
        -:  203:        } else if (refElem == this->prim) {
        -:  204:            this->prim = refElem->getNext();
        -:  205:            this->prim->setPrev(nullptr);
        -:  206:            delete refElem;
        -:  207:            this->sizeLDI--;
        -:  208:        }
        -:  209:            // verificam daca se sterge ultimul element
        -:  210:        else if (refElem == this->ultim) {
        -:  211:            this->ultim = refElem->getPrev();
        -:  212:            this->ultim->setNext(nullptr);
        -:  213:            delete refElem;
        -:  214:            this->sizeLDI--;
        -:  215:        }
        -:  216:            // se sterge un element oarecare din lista
        -:  217:        else {
        -:  218:            refElem->getPrev()->setNext(refElem->getNext());
        -:  219:            refElem->getNext()->setPrev(refElem->getPrev());
        -:  220:            delete refElem;
        -:  221:            this->sizeLDI--;
        -:  222:        }
        -:  223:    }
        -:  224:
        -:  225:    void swap(const unsigned int &thisPos, const unsigned int &otherPos) {
        -:  226:        // parcurgem lista pana la prima pozitie
        -:  227:        Node<TElem> *refThis = this->prim;
        -:  228:
        -:  229:        for (unsigned int i = 0; i < thisPos; i++)
        -:  230:            refThis = refThis->getNext();
        -:  231:
        -:  232:        // parcurgem lista pana la a doua pozitie
        -:  233:        Node<TElem> *refOther = this->prim;
        -:  234:
        -:  235:        for (unsigned int i = 0; i < otherPos; i++)
        -:  236:            refOther = refOther->getNext();
        -:  237:
        -:  238:        // swap intre elemente
        -:  239:        TElem temp = refThis->getData();
        -:  240:        refThis->setData(refOther->getData());
        -:  241:        refOther->setData(temp);
        -:  242:    }
        -:  243:
        -:  244:    /**
        -:  245:     * @brief Functia 'begin' / end -> returneaza un iterator peste primul / ultimul element din lista
        -:  246:     * @pre: true
        -:  247:     * @post: referinta catre primul / ultimul element din lista
        -:  248:     */
        -:  249:    IteratorLDI<TElem> begin() const { return IteratorLDI<TElem>(*this); }
        -:  250:
        -:  251:    IteratorLDI<TElem> end() const { return IteratorLDI<TElem>(*this, this->ultim->getNext()); }
        -:  252:
        -:  253:    // functie de delete a listei inlantuite
function _ZN3LDII3CarE11deleteNodesEP4NodeIS0_E called 0 returned 0% blocks executed 0%
    #####:  254:    void deleteNodes(Node<TElem> *ref) {
    #####:  255:        if (ref == ultim)
    %%%%%:  255-block  0
branch  0 never executed
branch  1 never executed
    #####:  256:            return;
    %%%%%:  256-block  0
    #####:  257:        deleteNodes(ref->getNext());
    %%%%%:  257-block  0
call    0 never executed
call    1 never executed
    #####:  258:        delete ref;
branch  0 never executed
branch  1 never executed
    %%%%%:  258-block  0
call    2 never executed
call    3 never executed
        -:  259:    }
        -:  260:
        -:  261:    // destructor
function _ZN3LDII3CarED2Ev called 0 returned 0% blocks executed 0%
    #####:  262:    ~LDI() { this->deleteNodes(this->prim); }
    %%%%%:  262-block  0
call    0 never executed
        -:  263:};
